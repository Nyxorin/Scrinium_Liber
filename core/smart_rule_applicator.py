import re
import json
import os
from typing import List, Dict

# Import optional dependencies (Guardian/Dict)
try:
    from core.dictionary import FrenchDictionary
    from core.ner_guardian import NerGuardian
    from core.rule_optimizer import RuleOptimizer # [Frequency Optimization]
except ImportError:
    FrenchDictionary = None
    NerGuardian = None
    RuleOptimizer = None

class SmartRuleApplicator:
    """
    Applies 'SmartRules' generated by the Analyst.
    Closing the loop: Logic Forge -> Analyst -> Applicator -> Corrector.
    """
    def __init__(self, rules_path: str = "data/logic_forge_rules.jsonl"):
        self.rules_path = rules_path
        self.rules = self._load_rules()
        
        # Dependencies for conditions
        self.dictionary = FrenchDictionary() if FrenchDictionary else None
        self.guardian = NerGuardian() if NerGuardian else None
        
        # [Frequency Optimization] Track rule usage
        self.optimizer = RuleOptimizer(rules_path) if RuleOptimizer else None

    def _load_rules(self) -> List[Dict]:
        """Loads rules from JSONL file."""
        rules = []
        if os.path.exists(self.rules_path):
            with open(self.rules_path, 'r') as f:
                for line in f:
                    if line.strip():
                        try:
                            rules.append(json.loads(line))
                        except:
                            pass
        return rules

    def apply_rules(self, text: str) -> str:
        """
        Applies all loaded SmartRules to the text.
        Respects conditions: 'dictionary_check_required', 'is_named_entity', etc.
        """
        if not self.rules:
            return text
            
        current_text = text
        
        for rule in self.rules:
            # Check if this is a legacy regex or a SmartRule
            if "trigger_word" in rule and "conditions" in rule:
                current_text = self._apply_smart_rule(rule, current_text)
            elif "pattern" in rule and "replacement" in rule:
                # Legacy regex fallback (Naive application)
                try:
                    current_text = re.sub(rule['pattern'], rule['replacement'], current_text)
                except:
                    pass
                    
        return current_text

    def save_stats(self):
        """Triggers the optimizer to sort and save rules."""
        if self.optimizer:
            self.optimizer.optimize_storage()

    def _apply_smart_rule(self, rule: Dict, text: str) -> str:
        """
        Applies a single SmartRule with Safety Conditions.
        """
        trigger = rule.get("trigger_word")
        correction = rule.get("correction")
        
        if not trigger or not correction:
            return text
            
        # Micro-Regex construction
        # We only want to replace whole words matching the trigger
        pattern = fr"\b{re.escape(trigger)}\b"
        
        # Find all matches
        matches = list(re.finditer(pattern, text))
        if not matches:
            return text
            
        # Apply replacement iteratively (handling offsets is tricky, so let's do simple word replace check)
        # Actually re.sub with a callback is cleaner for contextual checks
        
        def replacement_callback(match):
            word = match.group(0)
            start = match.start()
            
            # Check Conditions
            conditions = rule.get("conditions", [])
            
            # 1. Dictionary Check (Result must usually be valid)
            if "dictionary_check_required" in conditions:
                if self.dictionary and not self.dictionary.validate(correction):
                    # SmartRule says replace 'dient' -> 'client', but if 'client' isn't in dict (weird), abort.
                    # Usually checking correction validity is a given.
                    # More important: check if SOURCE is unknown?
                    # If "dictionary_check_required" implies "Only fix if Source is Unknown"?
                    # Let's assume Analyst intent: "d -> cl" is valid only if "dient" is unknown.
                    if self.dictionary.validate(word):
                        return word # Source is valid word -> Don't touch (e.g. 'Dient' surname)
            
            # 2. NER Safety
            if self.guardian:
                # Heuristic context extraction
                # Get char before
                ctx_before = text[max(0, start-5):start].split()
                last_word = ctx_before[-1] if ctx_before else ""
                
                if not self.guardian.is_safe_to_touch(word, last_word):
                    return word # Protected Entity

            # [Frequency Optimization] Success!
            if self.optimizer:
                self.optimizer.increment_usage(trigger)

            return correction

        try:
            return re.sub(pattern, replacement_callback, text)
        except:
            return text

if __name__ == "__main__":
    # Test
    app = SmartRuleApplicator()
    # Mocking a rule in memory for test
    app.rules = [{
        "type": "SmartRule",
        "trigger_word": "dient",
        "correction": "client",
        "conditions": ["dictionary_check_required"]
    }]
    
    # Text with errors
    sample = "Le dient a signé. Mais M. Dient n'a pas signé."
    print(f"Original: {sample}")
    print(f"Corrected: {app.apply_rules(sample)}")
